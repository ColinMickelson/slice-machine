import type {
  Plugin,
  FilenameAndData,
  Variations,
  Slice,
} from "@slicemachine/plugin-middleware/src";
import { FieldType } from "@slicemachine/plugin-middleware/src";

export const framework: Plugin["framework"] = "react";

// export const slice = (name: string): FilenameAndData<string> => ({
//   filename: "index.js",
//   data: `import React from 'react'
// import { RichText } from 'prismic-reactjs'

// const ${name} = ({ slice }) => (
//   <section>
//     <span className="title">
//       { slice.primary.title ? (
//         <RichText render={slice.primary.title} />
//       ) : (
//         <h2>Template slice, update me!</h2>
//       )}
//     </span>
//       { slice.primary.description ? (
//         <RichText render={slice.primary.description}/>
//       ) : (
//          <p>start by editing this slice from inside Slice Machine!</p>
//       )}
//       <style jsx>{\`
//           section {
//             max-width: 600px;
//             margin: 4em auto;
//             text-align: center;
//           }
//           .title {
//             color: #8592e0;
//           }
//       \`}</style>
//     </section>
//   )

//   export default ${name}
// `,
// });

export const slice = (slice: Slice): FilenameAndData<string>[] => {
  if (slice.variations.length === 0) return [];
  if (!slice.variations[0].primary) return [];
  const primary = slice.variations[0].primary;

  const name = safeComponentName(slice.name);

  const items = Object.entries(primary).map(([key, value]) => {
    const accessor = key.includes("-")
      ? `slice.primary["${key}"]`
      : `slice.primary.${key}`;
    const isRepeatable = ["Group"].includes(value.type);
    return snippets({
      type: value.type as FieldType,
      fieldText: accessor,
      isRepeatable,
    });
  });

  return [
    {
      filename: "index.jsx",
      data: `import React from 'react'
import {Link, Date as ParseDate, RichText} from 'prismic-reactjs';
    
const ${name} = ({ slice }) => (
  <section>
    ${items.join("\n    ")}
  </section>
)

export default ${name}
`,
    },
  ];
};

function safeComponentName(name: string): string {
  return `_${name.replace(/(^\w|-+\w)/g, (text) =>
    text.replace(/-/g, "").toUpperCase()
  )}`;
}

export const story = (
  path: string,
  sliceName: string,
  variations: Variations
): FilenameAndData<string> => {
  const exportStatements = variations
    .map((variation) => {
      const name = safeComponentName(variation.id);
      return `
export const ${name} = () => <MyComponent slice={${JSON.stringify(
        variation
      )}} />
${name}.storyName = '${variation.name}'
`;
    })
    .join("/n");

  return {
    filename: "index.stories.js",
    data: `import MyComponent from '${path}';
export default { title: '${sliceName}' }
${exportStatements}
`,
  };
};

export const index = (slices: Array<string>): FilenameAndData<string> => ({
  filename: "index.js",
  data: `// This file is generated by Slice Machine. Update with care!

${slices
  .map((slice) => `export { default as ${slice} } from './${slice}'`)
  .join("\n")}
`,
});

export const syntax = "jsx";

export const snippets = ({
  type,
  fieldText,
  useKey = false,
  isRepeatable = false,
}: {
  type: FieldType;
  fieldText: string;
  useKey?: boolean;
  isRepeatable?: boolean;
}): string => {
  if (isRepeatable) {
    const code = snippets({ type, fieldText, useKey: true });
    return `{ slice?.items?.map((item, i) => ${code}) }`;
  }
  switch (type) {
    case FieldType.Boolean:
      return `<span${
        useKey ? ` key="bool-\${i}" ` : ""
      }>{ ${fieldText} ? 'true' : 'false' }</span>`;

    case FieldType.Color:
      return `<span${
        useKey ? ` key="color-\${i}"` : ""
      } style={{ color: ${fieldText} }}>Some Text</span>`;

    case FieldType.ContentRelationship:
      return `<a${
        useKey ? ` key="${fieldText}-\${i}"` : ""
      } href={Link.url(${fieldText})}>My Link</a>`;

    case FieldType.Date:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}"` : ""
      }>{ ParseDate(${fieldText}) }</span>`;

    case FieldType.Embed:
      return `// you might want to use a lib here (eg. react-oembed-container)
<div${
        useKey ? ` key="${fieldText}-\${i}"` : ""
      } dangerouslySetInnerHTML={{ __html: ${fieldText} }} />`;

    case FieldType.GeoPoint:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}" ` : ""
      }>{ ${fieldText} }</span>`;

    case FieldType.Group:
      return "";

    case FieldType.Image:
      return `<img src={${fieldText}.url} alt={${fieldText}.alt} ${
        useKey ? `key="img-\${i}" ` : ""
      }/>`;

    case FieldType.IntegrationFields:
      return "";

    case FieldType.Link:
      return `<a${
        useKey ? ` key="${fieldText}-\${i}"` : ""
      } href={Link.url(${fieldText})}>My Link</a>`;

    case FieldType.LinkToMedia:
      return `<a${
        useKey ? ` key="${fieldText}-\${i}"` : ""
      } href={Link.url(${fieldText})}>My Link</a>`;

    case FieldType.Number:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}" ` : ""
      }>{ ${fieldText} }</span>`;

    case FieldType.Select:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}" ` : ""
      }>{ ${fieldText} }</span>`;

    case FieldType.StructuredText:
      return `<RichText render={${fieldText}} ${
        useKey ? `key="rich-text-\${i}"` : ""
      } />`;

    case FieldType.Text:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}" ` : ""
      }>{ ${fieldText} }</span>`;

    case FieldType.Timestamp:
      return `<span${
        useKey ? ` key="${fieldText}-\${i}" ` : ""
      }>{ ${fieldText} }>/span>`;

    case FieldType.UID:
      return `<span>{ ${fieldText} }</span>`;
    default:
      return `<span>{ ${fieldText} }</span>`;
  }
};
